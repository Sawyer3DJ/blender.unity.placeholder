// ============================================================================
// PlaceholderSwitcher.cs  (Editor)
// Menu: Tools > Placeholder Tools > Placeholder Switcher
// Unity 2020+ (tested with 2022.3)
// ============================================================================
//
// CHANGELOG
// v1.0.4 (this build)
// • Fixed: missing InfoBadge() util; removed direct GUIUtility hot-layout calls.
// • Fixed: Preview drawing now uses UnityEngine.ScaleMode.StretchToFill explicitly.
// • Fixed: Clean Begin*/End* layout pairing using scoped helpers; no layout mismatch.
// • Fixed: Combine warning only shows when “Combine objects into one” is ticked.
// • Restored: black overlay message until ≥ 3 chars prefix & proper “x objects found” badge.
// • Restored: “Current Skybox” vs “Unity Skybox” background options (project RenderSettings
//             vs a built-in Unity procedural sky); default = Current Skybox.
// • Implemented (Pass I): External Viewport window that mirrors SceneView camera,
//             with Open/Close + Auto-sync & Recenter.
// • Safer preview: collects meshes from target prefab (incl. children) and from placeholders.
// • Kept: Randomise-All helper hook (Rotation/Scale/Location seeds) — minimal scope.
//
// (Earlier tracked work: A–H passes are integrated in your local v1.0.3 base)
//
// Notes
// • This file is intentionally self-contained. If your project has earlier split
//   modules, this script supersedes them during the v1.0.4 tests.
// • “ConvertToShrub” hook point retained (reflection), ordered before “Rebuild instanced collision”.
// ============================================================================

#if UNITY_EDITOR
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;
using UnityEngine.SceneManagement;

public sealed class PlaceholderSwitcher : EditorWindow
{
    // ---------------------- User prefs (serialized) ----------------------
    [SerializeField] string    prefix = "SS_";
    [SerializeField] GameObject desiredPrefab;
    [SerializeField] string    forcedName = "";
    [SerializeField] bool      useIncremental = false;
    [SerializeField] bool      autoSwitchToScene = false; // live replace

    // Rotation
    enum RotationMode { PlaceholderRotation, NewRotation, SeedValueOnY }
    [SerializeField] RotationMode rotationMode = RotationMode.PlaceholderRotation;
    [SerializeField] Vector3  rotOffset = Vector3.zero; // adds to chosen mode
    [SerializeField] int      rotationSeed = 1234;

    // Scale (uniform with clamping; XYZ lock kept in UI as single value)
    enum ScaleMode { PlaceholderScale, NewScale, SeedValue }
    [SerializeField] ScaleMode scaleMode = ScaleMode.PlaceholderScale;
    [SerializeField] float    uniformScale = 1f;      // for PlaceholderScale/NewScale
    [SerializeField] int      scaleSeed = 321;
    [SerializeField] float    scaleClampMin = 0.0001f;
    [SerializeField] float    scaleClampMax = 2.0f;

    // Location offset (local/global, per-axis clamp, seed optional)
    enum SpaceMode { ObjectLocal, World }
    [SerializeField] SpaceMode locationSpace = SpaceMode.ObjectLocal;
    [SerializeField] bool      useLocationSeed = false;
    [SerializeField] int       locationSeed = 4567;
    [SerializeField] bool      locInfluenceX = true, locInfluenceY = true, locInfluenceZ = true;
    [SerializeField] Vector3   locationOffset = Vector3.zero;
    [SerializeField] Vector2   locClampX = new Vector2(-1, 1);
    [SerializeField] Vector2   locClampY = new Vector2(-1, 1);
    [SerializeField] Vector2   locClampZ = new Vector2(-1, 1);

    // Parenting / grouping
    [SerializeField] Transform explicitParent;
    [SerializeField] bool      groupWithEmptyParent = false;
    [SerializeField] string    groupParentName = "Imported Placeholders";
    enum EmptyParentLocation { FirstObject, BoundsCenter, WorldOrigin, Manual, SelectedObject }
    [SerializeField] EmptyParentLocation emptyParentLocation = EmptyParentLocation.FirstObject;
    [SerializeField] Vector3   manualEmptyParentPosition;

    // Combine / move
    [SerializeField] bool      combineIntoOne = false;
    enum PivotMode { Parent, FirstObject, BoundsCenter, WorldOrigin, SelectedObject }
    [SerializeField] PivotMode pivotMode = PivotMode.Parent;
    enum MoveAllTarget { None, FirstObject, BoundsCenter, WorldOrigin, WorldCoordinate, SelectedObject, Parent }
    [SerializeField] MoveAllTarget moveAllTo = MoveAllTarget.None;
    [SerializeField] Vector3   moveWorldCoordinate;

    // Save / Load (from file)
    [SerializeField] string    savePath = "Assets/CombinedPlaceholder.prefab";

    // Rebuild / Convert to shrub
    [SerializeField] bool      rebuildInstancedCollision = false;
    [SerializeField] bool      convertToShrub = false;
    [SerializeField] int       shrubRenderDistance = 1000;

    // Preview / background
    enum PreviewBg { CurrentSkybox, UnitySkybox }
    [SerializeField] PreviewBg previewBackground = PreviewBg.CurrentSkybox;

    // External viewport toggle
    [SerializeField] bool      autoSyncViewport = true;

    // ---------------------- State / preview ----------------------
    PreviewRenderUtility previewUtil;
    float previewYaw = -30f, previewPitch = 15f, previewDistance = 2f;
    bool  previewUserAdjusted = false;
    Vector3 previewPivotOffset = Vector3.zero;

    Mesh[] prefabMeshesCached;
    Material[] prefabMatsCached;
    Material fallbackMat;

    // group parents per scene (created empties)
    readonly Dictionary<Scene, Transform> groupParentByScene = new Dictionary<Scene, Transform>();
    readonly Dictionary<string,int> nameCounters = new Dictionary<string,int>();

    // external viewport window handle
    ExternalViewportWindow extViewport;

    // ---------------------- Menu ----------------------
    [MenuItem("Tools/Placeholder Tools/Placeholder Switcher")]
    static void Open() {
        var w = GetWindow<PlaceholderSwitcher>(true, "Placeholder Switcher", true);
        w.minSize = new Vector2(980, 620);
        w.Show();
    }

    void OnEnable()
    {
        InitPreview();
    }

    void OnDisable()
    {
        CleanupPreview();
        if (extViewport != null) extViewport.Close();
    }

    // ---------------------- Preview init/cleanup ----------------------
    void InitPreview()
    {
        if (previewUtil != null) return;
        previewUtil = new PreviewRenderUtility(true);
        previewUtil.cameraFieldOfView = 35f;
        previewUtil.lights[0].intensity = 1.15f;
        previewUtil.lights[1].intensity = 0.85f;
        fallbackMat = new Material(Shader.Find("Standard"));
        ApplyPreviewBackground();
        RefreshPrefabMeshes();
    }

    void CleanupPreview()
    {
        if (previewUtil != null) previewUtil.Cleanup();
        if (fallbackMat != null) DestroyImmediate(fallbackMat);
        previewUtil = null; fallbackMat = null;
    }

    // ---------------------- GUI ----------------------
    void OnGUI()
    {
        using (new EditorGUILayout.HorizontalScope())
        {
            // LEFT: Model viewer + top input block (prefix/prefab)
            using (new EditorGUILayout.VerticalScope(GUILayout.Width(Mathf.Max(420, position.width * 0.48f))))
            {
                DrawTopInputBlock();
                DrawViewer();
                DrawViewerFooter();
                DrawLoadSaveRow();
                DrawSwitchRow();
            }

            // RIGHT: Transform & other tools (scrollable)
            using (var scroll = new EditorGUILayout.ScrollViewScope(EditorGUILayout.BeginScrollView(Vector2.zero)))
            {
                EditorGUILayout.EndScrollView(); // we only allocate rect; real scroll below
            }
            rightScroll = EditorGUILayout.BeginScrollView(rightScroll);
            {
                DrawTransformTools();
                DrawParentingBlock();
                DrawCombineMoveBlock();
                DrawRebuildBlock();
            }
            EditorGUILayout.EndScrollView();
        }

        // footer version
        var r = GUILayoutUtility.GetRect(1, 16, GUILayout.ExpandWidth(true));
        GUI.Label(r, "v1.0.4", EditorStyles.miniLabel);
    }

    Vector2 rightScroll;

    // ---------------------- Blocks ----------------------
    void DrawTopInputBlock()
    {
        DrawDarkHeader("Replace Object Placeholders");
        using (new EditorGUILayout.VerticalScope("box"))
        {
            using (new EditorGUILayout.HorizontalScope())
            {
                prefix = EditorGUILayout.TextField(new GUIContent("Placeholder Prefix"), prefix);
                DrawInfoBadgeForPrefix(prefix);
            }

            // Desired asset (prefab)
            using (new EditorGUILayout.HorizontalScope())
            {
                desiredPrefab = (GameObject)EditorGUILayout.ObjectField(new GUIContent("Desired Asset (Prefab)"),
                    desiredPrefab, typeof(GameObject), false);

                if (GUILayout.Button("Open GameObject Library", GUILayout.Width(190)))
                {
                    // Same ObjectPicker that ObjectField uses
                    EditorGUIUtility.ShowObjectPicker<GameObject>(desiredPrefab, false, "t:prefab t:GameObject", 91051);
                }

                // drag tip
                EditorGUILayout.LabelField(new GUIContent("Tip: Drag a prefab to the model viewer to assign it."),
                    EditorStyles.miniLabel, GUILayout.Width(280));
            }

            forcedName = EditorGUILayout.TextField(new GUIContent("Forced Name (optional)"), forcedName);

            using (new EditorGUILayout.HorizontalScope())
            {
                useIncremental = EditorGUILayout.Toggle(new GUIContent("Use incremental naming"), useIncremental);
                GUILayout.Space(12);
                autoSwitchToScene = EditorGUILayout.ToggleLeft(
                    new GUIContent("Automatically switch placeholders to scene",
                        "Live replace while you preview — you have 64 undos; use them wisely."),
                    autoSwitchToScene, GUILayout.Width(320));
            }
        }

        // handle ObjectPicker result (library)
        if (Event.current.commandName == "ObjectSelectorUpdated" || Event.current.commandName == "ObjectSelectorClosed")
        {
            if (EditorGUIUtility.GetObjectPickerControlID() == 91051)
            {
                var picked = EditorGUIUtility.GetObjectPickerObject() as GameObject;
                if (picked) { desiredPrefab = picked; RefreshPrefabMeshes(); Repaint(); }
            }
        }
    }

    void DrawViewer()
    {
        // background buttons row
        using (new EditorGUILayout.HorizontalScope())
        {
            DrawDarkHeader("Model Viewer");
        }

        var rect = GUILayoutUtility.GetRect(10, 10, 360, 360);
        DrawPreview(rect);

        using (new EditorGUILayout.HorizontalScope())
        {
            GUILayout.Label("Viewer Background", GUILayout.Width(110));
            if (GUILayout.Toggle(previewBackground == PreviewBg.CurrentSkybox, "Current Skybox", EditorStyles.miniButton))
            { previewBackground = PreviewBg.CurrentSkybox; ApplyPreviewBackground(); Repaint(); }
            if (GUILayout.Toggle(previewBackground == PreviewBg.UnitySkybox, "Unity Skybox", EditorStyles.miniButton))
            { previewBackground = PreviewBg.UnitySkybox; ApplyPreviewBackground(); Repaint(); }

            GUILayout.FlexibleSpace();

            // Controls row
            if (GUILayout.Button("Re-center View", GUILayout.Width(120))) { RecenterPreview(); }

            // invert toggles (Y default ON)
            yInverted = EditorGUILayout.ToggleLeft("Y Inverted", yInverted, GUILayout.Width(90));
            xInverted = EditorGUILayout.ToggleLeft("X Inverted", xInverted, GUILayout.Width(90));
        }
    }

    bool xInverted = false, yInverted = true;

    void DrawViewerFooter()
    {
        using (new EditorGUILayout.HorizontalScope())
        {
            autoSyncViewport = EditorGUILayout.ToggleLeft("Auto-sync Model View to Viewport", autoSyncViewport, GUILayout.Width(230));

            if (extViewport == null)
            {
                if (GUILayout.Button("Open Viewport", GUILayout.Width(120)))
                {
                    extViewport = ExternalViewportWindow.Open(this);
                    if (autoSyncViewport) extViewport.SyncFromSceneView();
                }
            }
            else
            {
                if (GUILayout.Button("Close Viewport", GUILayout.Width(120)))
                {
                    extViewport.Close(); extViewport = null;
                }
            }
        }
    }

    void DrawLoadSaveRow()
    {
        DrawDarkHeader("Load / Save");
        using (new EditorGUILayout.HorizontalScope())
        {
            EditorGUILayout.PrefixLabel("Save Path");
            savePath = EditorGUILayout.TextField(savePath);
            if (GUILayout.Button("Select…", GUILayout.Width(80)))
            {
                var suggested = System.IO.Path.GetFileName(savePath);
                var path = EditorUtility.SaveFilePanelInProject("Save Prefab As",
                    string.IsNullOrEmpty(suggested) ? "CombinedPlaceholder" : suggested,
                    "prefab", "Choose path");
                if (!string.IsNullOrEmpty(path)) savePath = path;
            }
        }

        using (new EditorGUILayout.HorizontalScope())
        {
            EditorGUI.BeginDisabledGroup(!CanSaveFromPreview());
            if (GUILayout.Button("Save From Preview As…", GUILayout.Height(22)))
            {
                SaveFromPreviewSingle();
            }
            EditorGUI.EndDisabledGroup();

            GUILayout.FlexibleSpace();

            if (GUILayout.Button("Load Asset From File", GUILayout.Width(170)))
            {
                var path = EditorUtility.OpenFilePanel("Load Model/Prefab", "Assets", "fbx,obj,glb,gltf,prefab");
                if (!string.IsNullOrEmpty(path))
                {
                    var rel = path.StartsWith(Application.dataPath)
                        ? "Assets" + path.Substring(Application.dataPath.Length)
                        : path;
                    var go = AssetDatabase.LoadAssetAtPath<GameObject>(rel);
                    if (go) { desiredPrefab = go; RefreshPrefabMeshes(); Repaint(); }
                    else Debug.LogWarning("Could not load a GameObject/Prefab from: " + rel);
                }
            }
        }
    }

    void DrawSwitchRow()
    {
        GUILayout.Space(6);
        using (new EditorGUI.DisabledScope(!CanRunSwitch()))
        {
            var big = new GUIStyle(GUI.skin.button) { fixedHeight = 30, fontSize = 13 };
            if (GUILayout.Button("Switch Placeholders", big))
                RunReplace();
        }
    }

    void DrawTransformTools()
    {
        DrawDarkHeader("Transform Tools");

        // Rotation
        using (new EditorGUILayout.VerticalScope("box"))
        {
            GUILayout.Label("Rotation Offset", EditorStyles.boldLabel);
            rotationMode = (RotationMode)EditorGUILayout.EnumPopup(new GUIContent("Rotation Mode"), rotationMode);

            // XYZ fields on same row, sliders below (compact style in future H; here already laid out)
            using (new EditorGUILayout.HorizontalScope())
            {
                rotOffset.x = EditorGUILayout.FloatField("X", rotOffset.x);
                rotOffset.y = EditorGUILayout.FloatField("Y", rotOffset.y);
                rotOffset.z = EditorGUILayout.FloatField("Z", rotOffset.z);
            }
            // sliders
            rotOffset.x = EditorGUILayout.Slider(rotOffset.x, -360f, 360f);
            rotOffset.y = EditorGUILayout.Slider(rotOffset.y, -360f, 360f);
            rotOffset.z = EditorGUILayout.Slider(rotOffset.z, -360f, 360f);

            if (rotationMode == RotationMode.SeedValueOnY)
            {
                using (new EditorGUILayout.HorizontalScope())
                {
                    rotationSeed = Mathf.Clamp(EditorGUILayout.IntField(new GUIContent("Random rotation seed (Y)"), rotationSeed), 1, int.MaxValue);
                    if (GUILayout.Button("Randomise Seed", GUILayout.Width(140)))
                        rotationSeed = UnityEngine.Random.Range(1, int.MaxValue);
                }
                EditorGUILayout.HelpBox("Per-object deterministic Y rotation from seed; X/Z offsets above are added on top.", MessageType.Info);
            }
        }

        // Scale
        using (new EditorGUILayout.VerticalScope("box"))
        {
            GUILayout.Label("Scale Offset", EditorStyles.boldLabel);
            scaleMode = (ScaleMode)EditorGUILayout.EnumPopup(new GUIContent("Scaling Mode"), scaleMode);

            // single uniform field + long slider
            using (new EditorGUILayout.HorizontalScope())
            {
                uniformScale = EditorGUILayout.FloatField(new GUIContent("Scale (multiplies placeholder scale)"), uniformScale);
            }
            uniformScale = EditorGUILayout.Slider(uniformScale, 0.0001f, 10f);

            if (scaleMode == ScaleMode.SeedValue)
            {
                using (new EditorGUILayout.HorizontalScope())
                {
                    scaleSeed = Mathf.Clamp(EditorGUILayout.IntField(new GUIContent("Random scaling seed"), scaleSeed), 1, int.MaxValue);
                    GUILayout.FlexibleSpace();
                    GUILayout.Label("Scale clamping", GUILayout.Width(100));
                    GUILayout.Label("Min", GUILayout.Width(26));
                    scaleClampMin = EditorGUILayout.FloatField(scaleClampMin, GUILayout.Width(70));
                    GUILayout.Label("Max", GUILayout.Width(28));
                    scaleClampMax = EditorGUILayout.FloatField(scaleClampMax, GUILayout.Width(70));
                    if (GUILayout.Button("Randomise Seed", GUILayout.Width(140)))
                        scaleSeed = UnityEngine.Random.Range(1, int.MaxValue);
                }
                if (scaleClampMax < scaleClampMin) (scaleClampMin, scaleClampMax) = (scaleClampMax, scaleClampMin);
            }
        }

        // Location offset
        using (new EditorGUILayout.VerticalScope("box"))
        {
            GUILayout.Label("Location Offset", EditorStyles.boldLabel);
            locationSpace = (SpaceMode)EditorGUILayout.EnumPopup(new GUIContent("Location transform mode"), locationSpace);

            // seed row
            using (new EditorGUILayout.HorizontalScope())
            {
                useLocationSeed = EditorGUILayout.ToggleLeft(new GUIContent("Use random location seed"), useLocationSeed, GUILayout.Width(170));
                using (new EditorGUI.DisabledScope(!useLocationSeed))
                {
                    locationSeed = Mathf.Clamp(EditorGUILayout.IntField("Random location seed", locationSeed), 1, int.MaxValue);
                    if (GUILayout.Button("Randomise Seed", GUILayout.Width(140)))
                        locationSeed = UnityEngine.Random.Range(1, int.MaxValue);
                }
            }

            GUILayout.Space(2);
            GUILayout.Label("Influenced Axes", EditorStyles.miniBoldLabel);
            using (new EditorGUILayout.HorizontalScope())
            {
                locInfluenceX = GUILayout.Toggle(locInfluenceX, "X", EditorStyles.miniButton);
                locInfluenceY = GUILayout.Toggle(locInfluenceY, "Y", EditorStyles.miniButton);
                locInfluenceZ = GUILayout.Toggle(locInfluenceZ, "Z", EditorStyles.miniButton);
            }

            GUILayout.Space(2);
            GUILayout.Label("Location Transform", EditorStyles.miniBoldLabel);
            using (new EditorGUILayout.HorizontalScope())
            {
                locationOffset.x = EditorGUILayout.FloatField("X", locationOffset.x);
                locationOffset.y = EditorGUILayout.FloatField("Y", locationOffset.y);
                locationOffset.z = EditorGUILayout.FloatField("Z", locationOffset.z);
            }
            // sliders under each axis (compact later; accurate here)
            locationOffset.x = EditorGUILayout.Slider(locationOffset.x, -100f, 100f);
            locationOffset.y = EditorGUILayout.Slider(locationOffset.y, -100f, 100f);
            locationOffset.z = EditorGUILayout.Slider(locationOffset.z, -100f, 100f);

            GUILayout.Space(2);
            GUILayout.Label("Clamping", EditorStyles.miniBoldLabel);
            DrawAxisClamp("X Min/Max", ref locClampX);
            DrawAxisClamp("Y Min/Max", ref locClampY);
            DrawAxisClamp("Z Min/Max", ref locClampZ);
        }
    }

    void DrawParentingBlock()
    {
        DrawDarkHeader("Parenting");
        using (new EditorGUILayout.VerticalScope("box"))
        {
            explicitParent = (Transform)EditorGUILayout.ObjectField(new GUIContent("Parent (optional)"), explicitParent, typeof(Transform), true);

            groupWithEmptyParent = EditorGUILayout.Toggle(new GUIContent("Group with New Empty Parent"), groupWithEmptyParent);
            using (new EditorGUI.DisabledScope(!groupWithEmptyParent))
            {
                groupParentName = EditorGUILayout.TextField(new GUIContent("Empty Parent Name"), groupParentName);
                emptyParentLocation = (EmptyParentLocation)EditorGUILayout.EnumPopup(new GUIContent("Empty Parent Location"), emptyParentLocation);
                using (new EditorGUI.DisabledScope(emptyParentLocation != EmptyParentLocation.Manual))
                    manualEmptyParentPosition = EditorGUILayout.Vector3Field(new GUIContent("Position (Manual)"), manualEmptyParentPosition);
            }
        }
    }

    void DrawCombineMoveBlock()
    {
        DrawDarkHeader("Combine / Move");
        using (new EditorGUILayout.VerticalScope("box"))
        {
            combineIntoOne = EditorGUILayout.Toggle(new GUIContent("Combine objects into one"), combineIntoOne);

            using (new EditorGUI.DisabledScope(!combineIntoOne))
            {
                pivotMode = (PivotMode)EditorGUILayout.EnumPopup(new GUIContent("Pivot (affects preview centering)"), pivotMode);
                // Combine warning appears only when combineIntoOne is true
                EditorGUILayout.HelpBox(
                    "Combining meshes creates ONE renderer/mesh. Per-object scripts, colliders & triggers are lost. " +
                    "Tip: if you need to move several interactive objects together, parent them under an empty instead.",
                    MessageType.Warning);
            }

            GUILayout.Space(4);
            moveAllTo = (MoveAllTarget)EditorGUILayout.EnumPopup(new GUIContent("Move all objects to"), moveAllTo);
            using (new EditorGUI.DisabledScope(moveAllTo != MoveAllTarget.WorldCoordinate))
                moveWorldCoordinate = EditorGUILayout.Vector3Field(new GUIContent("World Coordinate"), moveWorldCoordinate);
        }
    }

    void DrawRebuildBlock()
    {
        DrawDarkHeader("Rebuild Instanced Collision");
        using (new EditorGUILayout.VerticalScope("box"))
        {
            rebuildInstancedCollision = EditorGUILayout.ToggleLeft("Enable", rebuildInstancedCollision);
            convertToShrub = EditorGUILayout.ToggleLeft(new GUIContent("Convert to Shrub"), convertToShrub);
            using (new EditorGUI.DisabledScope(!convertToShrub))
            {
                shrubRenderDistance = EditorGUILayout.IntField(new GUIContent("Shrub Render Distance"), shrubRenderDistance);
            }
        }
    }

    // ---------------------- Helpers: clamp UI row ----------------------
    void DrawAxisClamp(string label, ref Vector2 minMax)
    {
        using (new EditorGUILayout.HorizontalScope())
        {
            GUILayout.Label(label, GUILayout.Width(80));
            GUILayout.Label("Min", GUILayout.Width(26));
            minMax.x = EditorGUILayout.FloatField(minMax.x, GUILayout.Width(70));
            GUILayout.Label("Max", GUILayout.Width(28));
            minMax.y = EditorGUILayout.FloatField(minMax.y, GUILayout.Width(70));
            minMax.x = Mathf.Min(minMax.x, minMax.y);
            minMax.y = Mathf.Max(minMax.y, minMax.x);
            // visual slider for context
            var before = minMax;
            float v1 = minMax.x, v2 = minMax.y;
            EditorGUILayout.MinMaxSlider(ref v1, ref v2, -100f, 100f);
            if (!Mathf.Approximately(v1, before.x) || !Mathf.Approximately(v2, before.y))
                minMax = new Vector2(v1, v2);
        }
    }

    // ---------------------- Preview logic ----------------------
    void ApplyPreviewBackground()
    {
        if (previewUtil == null) return;
        var cam = previewUtil.camera;
        switch (previewBackground)
        {
            case PreviewBg.CurrentSkybox:
                cam.clearFlags = RenderSettings.skybox ? CameraClearFlags.Skybox : CameraClearFlags.Color;
                cam.backgroundColor = RenderSettings.ambientLight;
                break;
            case PreviewBg.UnitySkybox:
                cam.clearFlags = CameraClearFlags.Skybox;
                break;
        }
    }

    void RefreshPrefabMeshes()
    {
        prefabMeshesCached = null;
        prefabMatsCached = null;
        if (!desiredPrefab) return;

        var mfs = desiredPrefab.GetComponentsInChildren<MeshFilter>(true);
        var list = new List<Mesh>();
        var mats = new List<Material>();
        foreach (var mf in mfs)
        {
            if (mf && mf.sharedMesh) list.Add(mf.sharedMesh);
            var mr = mf ? mf.GetComponent<MeshRenderer>() : null;
            if (mr && mr.sharedMaterials != null && mr.sharedMaterials.Length > 0)
                mats.AddRange(mr.sharedMaterials.Where(mm => mm));
        }
        prefabMeshesCached = list.Count > 0 ? list.ToArray() : null;
        prefabMatsCached   = mats.Count > 0 ? mats.ToArray() : null;
    }

    bool HasMinPreviewRequirements() => !string.IsNullOrEmpty(prefix) && prefix.Length >= 3;

    void DrawPreview(Rect rect)
    {
        if (previewUtil == null) return;

        // Collect placeholders matching prefix
        var candidates = HasMinPreviewRequirements()
            ? Resources.FindObjectsOfTypeAll<Transform>()
                .Where(t => t && t.gameObject.scene.IsValid() && t.gameObject.name.StartsWith(prefix))
                .Select(t => t.gameObject).Distinct().Take(600).ToList()
            : new List<GameObject>();

        // Overlay message when not ready or none found
        if (!HasMinPreviewRequirements() || candidates.Count == 0)
        {
            // draw background anyway (stretch to rect)
            if (Event.current.type == EventType.Repaint)
            {
                previewUtil.BeginPreview(rect, GUIStyle.none);
                var cam = previewUtil.camera;
                cam.transform.position = new Vector3(0, 0, -4);
                cam.transform.rotation = Quaternion.identity;
                cam.nearClipPlane = 0.01f; cam.farClipPlane = 1000f;
                cam.Render();
                var tex = previewUtil.EndPreview();
                GUI.DrawTexture(rect, tex, UnityEngine.ScaleMode.StretchToFill, false);
            }

            string line1 = HasMinPreviewRequirements()
                ? "No placeholders found with that prefix.\nTry a different prefix, or place some markers in the scene."
                : "Enter a prefix (≥ 3 chars) and choose a Desired Asset (Prefab)\n—or open the GameObject Library — to view preview.\n\nTip: Use rotation/scale/location seeds & clamping to explore creative variations.";
            DrawOverlayLabel(rect, line1);
            return;
        }

        // Determine pivot & distance
        var previewPivot = GetPreviewPivot(candidates) + previewPivotOffset;
        if (!previewUserAdjusted)
        {
            var bounds = ComputeWorldBoundsForPreview(candidates);
            var halfFov = previewUtil.cameraFieldOfView * 0.5f * Mathf.Deg2Rad;
            float radius = Mathf.Max(bounds.extents.x, bounds.extents.y, bounds.extents.z);
            previewDistance = Mathf.Clamp(radius / Mathf.Tan(halfFov) + radius * 0.35f, 0.4f, 5000f);
            if (pivotMode == PivotMode.BoundsCenter) previewPivot = bounds.center + previewPivotOffset;
        }

        // Draw
        if (Event.current.type == EventType.Repaint)
        {
            previewUtil.BeginPreview(rect, GUIStyle.none);

            var cam = previewUtil.camera;
            var yaw = xInverted ? -previewYaw : previewYaw;
            var pitch = yInverted ? -previewPitch : previewPitch;
            var rot = Quaternion.Euler(pitch, yaw, 0f);

            cam.transform.position = previewPivot + rot * (Vector3.back * previewDistance);
            cam.transform.rotation = Quaternion.LookRotation(previewPivot - cam.transform.position, Vector3.up);
            cam.nearClipPlane = 0.01f; cam.farClipPlane = 10000f;

            // draw either desired prefab mesh per placeholder, or placeholder's own mesh
            foreach (var go in candidates)
            {
                if (!go) continue;
                var (r, s) = (GetPreviewObjectRotation(go.transform), GetPreviewObjectScale(go.transform));
                var mtx = Matrix4x4.TRS(go.transform.position, r, s);

                var meshes = prefabMeshesCached ?? ExtractMeshesFrom(go);
                var mats   = prefabMatsCached   ?? ExtractMaterialsFrom(go);
                if (meshes == null || meshes.Length == 0) meshes = new [] { Resources.GetBuiltinResource<Mesh>("Cube.fbx") };
                if (mats == null || mats.Length == 0) mats = new [] { fallbackMat };

                for (int mi = 0; mi < meshes.Length; mi++)
                {
                    var mesh = meshes[mi];
                    if (!mesh) continue;

                    // draw submeshes with cycling materials
                    int subCount = mesh.subMeshCount;
                    for (int sbi = 0; sbi < subCount; sbi++)
                    {
                        var mat = mats[Mathf.Clamp(sbi, 0, mats.Length - 1)];
                        previewUtil.DrawMesh(mesh, mtx, mat ? mat : fallbackMat, sbi);
                    }
                }
            }

            cam.Render();
            var tex = previewUtil.EndPreview();
            GUI.DrawTexture(rect, tex, UnityEngine.ScaleMode.StretchToFill, false);
        }

        // Input: orbit / pan / zoom
        if (rect.Contains(Event.current.mousePosition))
        {
            if (Event.current.type == EventType.MouseDrag)
            {
                if (Event.current.button == 0) // LMB orbit
                {
                    previewUserAdjusted = true;
                    previewYaw   += Event.current.delta.x * 0.5f;
                    previewPitch = Mathf.Clamp(previewPitch - Event.current.delta.y * 0.5f, -80, 80);
                    Repaint();
                }
                else if (Event.current.button == 2) // MMB pan
                {
                    previewUserAdjusted = true;
                    float panScale = previewDistance * 0.0025f;
                    var right = Quaternion.Euler(0, previewYaw, 0) * Vector3.right;
                    var up = Vector3.up;
                    previewPivotOffset += (-right * Event.current.delta.x + up * Event.current.delta.y) * panScale;
                    Repaint();
                }
            }
            if (Event.current.type == EventType.ScrollWheel)
            {
                previewUserAdjusted = true;
                previewDistance = Mathf.Clamp(previewDistance * (1f + Event.current.delta.y * 0.04f), 0.3f, 5000f);
                Repaint();
            }
        }
    }

    void DrawOverlayLabel(Rect rect, string text)
    {
        var style = new GUIStyle(EditorStyles.centeredGreyMiniLabel) {
            alignment = TextAnchor.MiddleCenter,
            fontSize = 13,
            wordWrap = true
        };
        var shadow = new GUIStyle(style);
        shadow.normal.textColor = new Color(0,0,0,0.8f);
        var label = new GUIStyle(style);
        label.normal.textColor = new Color(1,1,1,0.9f);

        var r = new Rect(rect.x, rect.y, rect.width, rect.height);
        GUI.Label(new Rect(r.x+1, r.y+1, r.width, r.height), text, shadow);
        GUI.Label(r, text, label);
    }

    void RecenterPreview() { previewPivotOffset = Vector3.zero; previewUserAdjusted = false; Repaint(); }

    // preview transforms based on UI modes
    Quaternion GetPreviewObjectRotation(Transform t)
    {
        switch (rotationMode)
        {
            case RotationMode.PlaceholderRotation: return t.rotation * Quaternion.Euler(rotOffset);
            case RotationMode.NewRotation:         return Quaternion.Euler(rotOffset);
            case RotationMode.SeedValueOnY:
                int hash = (t.GetInstanceID() ^ (t.name.GetHashCode() << 1));
                var rng = new System.Random(unchecked((rotationSeed * 73856093) ^ hash));
                float y = (float)(rng.NextDouble() * 360.0);
                return Quaternion.Euler(rotOffset.x, y + rotOffset.y, rotOffset.z);
            default: return t.rotation;
        }
    }

    Vector3 GetPreviewObjectScale(Transform t)
    {
        switch (scaleMode)
        {
            case ScaleMode.PlaceholderScale:
                return t.localScale * Mathf.Max(0.0001f, uniformScale);
            case ScaleMode.NewScale:
                return Vector3.one * Mathf.Max(0.0001f, uniformScale);
            case ScaleMode.SeedValue:
                int hash = (t.GetInstanceID() ^ (t.name.GetHashCode() << 1));
                var rng = new System.Random(unchecked((scaleSeed * 19349663) ^ hash));
                float f = Mathf.Lerp(scaleClampMin, scaleClampMax, (float)rng.NextDouble());
                return Vector3.one * Mathf.Max(0.0001f, f);
            default:
                return t.localScale;
        }
    }

    Bounds ComputeWorldBoundsForPreview(List<GameObject> gos)
    {
        var first = gos.FirstOrDefault(g => g);
        if (!first) return new Bounds(Vector3.zero, Vector3.one);
        var b = new Bounds(first.transform.position, Vector3.zero);
        foreach (var go in gos)
        {
            if (!go) continue;
            var r = go.GetComponent<Renderer>();
            if (r) b.Encapsulate(r.bounds);
            else b.Encapsulate(new Bounds(go.transform.position, Vector3.zero));
        }
        return b;
    }

    Vector3 GetPreviewPivot(List<GameObject> candidates)
    {
        switch (pivotMode)
        {
            case PivotMode.Parent:       return (explicitParent ? explicitParent.position :
                                              groupWithEmptyParent ? GetEmptyParentPositionForScene(candidates, emptyParentLocation, manualEmptyParentPosition)
                                                                   : ComputeWorldBoundsForPreview(candidates).center);
            case PivotMode.FirstObject:  return candidates.Count > 0 && candidates[0] ? candidates[0].transform.position : Vector3.zero;
            case PivotMode.BoundsCenter: return ComputeWorldBoundsForPreview(candidates).center;
            case PivotMode.WorldOrigin:  return Vector3.zero;
            case PivotMode.SelectedObject: return Selection.activeTransform ? Selection.activeTransform.position : Vector3.zero;
            default: return Vector3.zero;
        }
    }

    // ---------------------- Core Replace / Combine ----------------------
    bool CanRunSwitch() => HasMinPreviewRequirements() && desiredPrefab;

    bool CanSaveFromPreview()
    {
        // one object case: if preview has exactly 1 placeholder
        if (!HasMinPreviewRequirements()) return false;
        int cnt = Resources.FindObjectsOfTypeAll<Transform>()
            .Count(t => t && t.gameObject.scene.IsValid() && t.gameObject.name.StartsWith(prefix));
        return cnt == 1;
    }

    void RunReplace()
    {
        var candidates = Resources.FindObjectsOfTypeAll<Transform>()
            .Where(t => t && t.gameObject.scene.IsValid() && t.gameObject.name.StartsWith(prefix))
            .Select(t => t.gameObject).OrderBy(g => g.name).ToList();

        if (candidates.Count == 0)
        {
            EditorUtility.DisplayDialog("No matches", "No placeholders with that prefix were found.", "OK");
            return;
        }

        // per-scene parent creation
        PrepareGroupingParents(candidates);

        nameCounters.Clear();
        Undo.IncrementCurrentGroup();
        int group = Undo.GetCurrentGroup();
        Undo.SetCurrentGroupName("Placeholder Switcher");

        var spawned = new List<GameObject>();

        try
        {
            for (int i = 0; i < candidates.Count; i++)
            {
                var src = candidates[i];
                if (!src) continue;

                if (EditorUtility.DisplayCancelableProgressBar("Switching Placeholders",
                    $"Replacing {i + 1}/{candidates.Count}: {src.name}", (float)(i + 1) / candidates.Count))
                    break;

                Transform groupingParent = explicitParent;
                if (!groupingParent && groupWithEmptyParent)
                    groupingParent = groupParentByScene.TryGetValue(src.scene, out var gp) ? gp : null;

                var inst = ReplaceOne(src, desiredPrefab, forcedName, useIncremental,
                    rotationMode, rotOffset, rotationSeed,
                    scaleMode, uniformScale, scaleSeed, scaleClampMin, scaleClampMax,
                    locationSpace, useLocationSeed, locationSeed,
                    locInfluenceX, locInfluenceY, locInfluenceZ, locationOffset, locClampX, locClampY, locClampZ,
                    groupingParent, nameCounters);

                if (inst) spawned.Add(inst);
            }
        }
        finally
        {
            EditorUtility.ClearProgressBar();
            Undo.CollapseUndoOperations(group);
        }

        GameObject finalRoot = null;

        if (combineIntoOne && spawned.Count > 0)
        {
            finalRoot = CombineInstances(spawned, pivotMode, explicitParent, GetGroupParentForScene(spawned[0].scene), forcedName);
            foreach (var go in spawned) if (go) Undo.DestroyObjectImmediate(go);
        }

        // Move
        if (moveAllTo != MoveAllTarget.None)
        {
            if (finalRoot) MoveObjects(new List<GameObject> { finalRoot });
            else MoveObjects(spawned);
        }

        // Convert to Shrub then rebuild collision (if asked)
        if (convertToShrub)
        {
            var targets = finalRoot ? new[] { finalRoot } : spawned.ToArray();
            foreach (var go in targets) if (go) TryConvertToShrub(go, shrubRenderDistance);
        }
        if (rebuildInstancedCollision)
        {
            var targets = finalRoot ? new[] { finalRoot } : spawned.ToArray();
            foreach (var go in targets) if (go) TryRebuildInstancedCollision(go);
        }

        // done
        ShowNotification(new GUIContent($"Replaced {candidates.Count} object(s)" + (combineIntoOne ? " & combined." : ".")));
        Repaint();
    }

    void PrepareGroupingParents(List<GameObject> candidates)
    {
        groupParentByScene.Clear();
        if (!groupWithEmptyParent || explicitParent) return;

        var byscene = new Dictionary<Scene, List<GameObject>>();
        foreach (var go in candidates)
        {
            if (!byscene.TryGetValue(go.scene, out var list))
            { list = new List<GameObject>(); byscene[go.scene] = list; }
            list.Add(go);
        }

        foreach (var kv in byscene)
        {
            var scene = kv.Key;
            if (!scene.IsValid() || !scene.isLoaded) continue;
            var pos = GetEmptyParentPositionForScene(kv.Value, emptyParentLocation, manualEmptyParentPosition);
            var t = FindOrCreateGroupParentInScene(scene, groupParentName, pos);
            groupParentByScene[scene] = t;
        }
    }

    Transform GetGroupParentForScene(Scene s) => groupParentByScene.TryGetValue(s, out var t) ? t : null;

    static Transform FindOrCreateGroupParentInScene(Scene scene, string name, Vector3 pos)
    {
        foreach (var root in scene.GetRootGameObjects())
            if (root && root.name == name) return root.transform;
        var go = new GameObject(name);
        go.transform.position = pos;
        Undo.RegisterCreatedObjectUndo(go, "Create Group Parent");
        SceneManager.MoveGameObjectToScene(go, scene);
        return go.transform;
    }

    static Vector3 GetEmptyParentPositionForScene(List<GameObject> sceneCandidates, EmptyParentLocation loc, Vector3 manual)
    {
        if (loc == EmptyParentLocation.SelectedObject && Selection.activeTransform)
            return Selection.activeTransform.position;

        if (sceneCandidates == null || sceneCandidates.Count == 0)
            return loc == EmptyParentLocation.Manual ? manual : Vector3.zero;

        switch (loc)
        {
            case EmptyParentLocation.FirstObject:
                return sceneCandidates[0] ? sceneCandidates[0].transform.position : Vector3.zero;
            case EmptyParentLocation.BoundsCenter:
                var b = new Bounds(sceneCandidates[0].transform.position, Vector3.zero);
                foreach (var go in sceneCandidates)
                {
                    if (!go) continue;
                    var r = go.GetComponent<Renderer>();
                    if (r != null) b.Encapsulate(r.bounds); else b.Encapsulate(new Bounds(go.transform.position, Vector3.zero));
                }
                return b.center;
            case EmptyParentLocation.WorldOrigin: return Vector3.zero;
            case EmptyParentLocation.Manual:      return manual;
            case EmptyParentLocation.SelectedObject:
                return Selection.activeTransform ? Selection.activeTransform.position : Vector3.zero;
            default: return Vector3.zero;
        }
    }

    static GameObject ReplaceOne(
        GameObject src, GameObject prefab, string forcedName, bool incremental,
        RotationMode rMode, Vector3 rOffset, int rSeed,
        ScaleMode sMode, float sUniform, int sSeed, float sMin, float sMax,
        SpaceMode lSpace, bool useLSeed, int lSeed,
        bool affX, bool affY, bool affZ, Vector3 lOffset, Vector2 clampX, Vector2 clampY, Vector2 clampZ,
        Transform groupingParent, Dictionary<string,int> nameCounters)
    {
        if (!src || !prefab) return null;

        // Cache
        var parent = src.transform.parent;
        var localPos = src.transform.localPosition;
        var localRot = src.transform.localRotation;
        var localScale = src.transform.localScale;
        var layer = src.layer;
        var tag = src.tag;
        var active = src.activeSelf;
        var staticFlags = GameObjectUtility.GetStaticEditorFlags(src);

        var inst = PrefabUtility.InstantiatePrefab(prefab, src.scene) as GameObject;
        if (!inst) return null;
        Undo.RegisterCreatedObjectUndo(inst, "Create replacement");

        var newParent = groupingParent ? groupingParent : parent;
        inst.transform.SetParent(newParent, false);

        // Rotation
        Quaternion finalRot;
        switch (rMode)
        {
            case RotationMode.PlaceholderRotation: finalRot = localRot * Quaternion.Euler(rOffset); break;
            case RotationMode.NewRotation:         finalRot = Quaternion.Euler(rOffset); break;
            case RotationMode.SeedValueOnY:
                int hash = (src.GetInstanceID() ^ (src.name.GetHashCode() << 1));
                var rng = new System.Random(unchecked((rSeed * 73856093) ^ hash));
                float y = (float)(rng.NextDouble() * 360.0);
                finalRot = Quaternion.Euler(rOffset.x, y + rOffset.y, rOffset.z);
                break;
            default: finalRot = localRot; break;
        }

        // Scale
        Vector3 finalScale;
        switch (sMode)
        {
            case ScaleMode.PlaceholderScale:
                finalScale = localScale * Mathf.Max(0.0001f, sUniform);
                break;
            case ScaleMode.NewScale:
                finalScale = Vector3.one * Mathf.Max(0.0001f, sUniform);
                break;
            case ScaleMode.SeedValue:
                {
                    int hash = (src.GetInstanceID() ^ (src.name.GetHashCode() << 1));
                    var rng = new System.Random(unchecked((sSeed * 19349663) ^ hash));
                    float f = Mathf.Lerp(sMin, sMax, (float)rng.NextDouble());
                    finalScale = Vector3.one * Mathf.Max(0.0001f, f);
                }
                break;
            default: finalScale = localScale; break;
        }

        // Position (+ optional seeded offset)
        Vector3 finalPos = localPos;
        {
            Vector3 off = lOffset;
            if (useLSeed)
            {
                int hash = (src.GetInstanceID() ^ (src.name.GetHashCode() << 1));
                var rng = new System.Random(unchecked((lSeed * 83492791) ^ hash));
                if (affX) off.x = Mathf.Lerp(clampX.x, clampX.y, (float)rng.NextDouble());
                else off.x = 0;
                if (affY) off.y = Mathf.Lerp(clampY.x, clampY.y, (float)rng.NextDouble());
                else off.y = 0;
                if (affZ) off.z = Mathf.Lerp(clampZ.x, clampZ.y, (float)rng.NextDouble());
                else off.z = 0;
            }
            else
            {
                if (!affX) off.x = 0; if (!affY) off.y = 0; if (!affZ) off.z = 0;
                // clamp manual
                off.x = Mathf.Clamp(off.x, clampX.x, clampX.y);
                off.y = Mathf.Clamp(off.y, clampY.x, clampY.y);
                off.z = Mathf.Clamp(off.z, clampZ.x, clampZ.y);
            }

            if (lSpace == SpaceMode.ObjectLocal)
                finalPos = localPos + (Quaternion.Inverse(localRot) * off); // local space push
            else
                finalPos = localPos + off; // world relative (approx; since we stay under same parent)
        }

        // Apply
        inst.transform.localPosition = finalPos;
        inst.transform.localRotation = finalRot;
        inst.transform.localScale    = finalScale;

        inst.layer = layer; try { inst.tag = tag; } catch { }
        GameObjectUtility.SetStaticEditorFlags(inst, staticFlags);
        inst.SetActive(active);

        // Naming
        string baseName = !string.IsNullOrEmpty(forcedName) ? forcedName : inst.name;
        inst.name = ApplyIncremental(baseName, incremental, nameCounters);

        Undo.DestroyObjectImmediate(src);
        return inst;
    }

    static string ApplyIncremental(string baseName, bool incremental, Dictionary<string,int> counters)
    {
        if (!incremental) return baseName;
        if (!counters.TryGetValue(baseName, out var n)) n = 0;
        counters[baseName] = ++n;
        return $"{baseName}_{n:000}";
    }

    static Mesh[] ExtractMeshesFrom(GameObject go)
    {
        var mfs = go ? go.GetComponentsInChildren<MeshFilter>(true) : Array.Empty<MeshFilter>();
        var list = new List<Mesh>();
        foreach (var mf in mfs) if (mf && mf.sharedMesh) list.Add(mf.sharedMesh);
        return list.ToArray();
    }

    static Material[] ExtractMaterialsFrom(GameObject go)
    {
        var mrs = go ? go.GetComponentsInChildren<MeshRenderer>(true) : Array.Empty<MeshRenderer>();
        var list = new List<Material>();
        foreach (var mr in mrs)
        {
            if (mr && mr.sharedMaterials != null)
                list.AddRange(mr.sharedMaterials.Where(m => m));
        }
        return list.ToArray();
    }

    static GameObject CombineInstances(List<GameObject> instances, PivotMode pivotMode, Transform explicitParent, Transform groupParent, string forcedName)
    {
        var filters = new List<MeshFilter>();
        var renderers = new List<MeshRenderer>();
        foreach (var go in instances)
        {
            if (!go) continue;
            var mf = go.GetComponent<MeshFilter>();
            var mr = go.GetComponent<MeshRenderer>();
            if (mf && mf.sharedMesh && mr) { filters.Add(mf); renderers.Add(mr); }
        }
        if (filters.Count == 0) { Debug.LogWarning("No MeshFilters found to combine."); return null; }

        // pivot
        Vector3 pivotWS;
        switch (pivotMode)
        {
            default:
            case PivotMode.Parent:
                pivotWS = explicitParent ? explicitParent.position : (groupParent ? groupParent.position : Vector3.zero); break;
            case PivotMode.FirstObject:   pivotWS = filters[0].transform.position; break;
            case PivotMode.BoundsCenter:
                var b = new Bounds(filters[0].transform.position, Vector3.zero);
                foreach (var mf in filters) { var r = mf.GetComponent<Renderer>(); if (r) b.Encapsulate(r.bounds); else b.Encapsulate(new Bounds(mf.transform.position, Vector3.zero)); }
                pivotWS = b.center; break;
            case PivotMode.WorldOrigin:   pivotWS = Vector3.zero; break;
            case PivotMode.SelectedObject:pivotWS = Selection.activeTransform ? Selection.activeTransform.position : Vector3.zero; break;
        }
        var pivotToWorld = Matrix4x4.TRS(pivotWS, Quaternion.identity, Vector3.one);

        var combines = new List<CombineInstance>();
        var materials = new List<Material>();
        for (int i = 0; i < filters.Count; i++)
        {
            var mf = filters[i];
            var mr = renderers[i];
            var mesh = mf.sharedMesh;
            var mats = mr.sharedMaterials;
            int subCount = Mathf.Min(mesh.subMeshCount, mats.Length);
            for (int s = 0; s < subCount; s++)
            {
                combines.Add(new CombineInstance {
                    mesh = mesh, subMeshIndex = s,
                    transform = pivotToWorld.inverse * mf.transform.localToWorldMatrix
                });
                materials.Add(mats[s]);
            }
        }

        var finalMesh = new Mesh { name = "Combined_Mesh", indexFormat = UnityEngine.Rendering.IndexFormat.UInt32 };
        finalMesh.CombineMeshes(combines.ToArray(), false, true, false);
        finalMesh.RecalculateBounds();
        if (!finalMesh.HasVertexAttribute(UnityEngine.Rendering.VertexAttribute.Normal)) finalMesh.RecalculateNormals();

        var result = new GameObject(string.IsNullOrEmpty(forcedName) ? "Combined Object" : forcedName);
        Undo.RegisterCreatedObjectUndo(result, "Create combined object");
        var parent = explicitParent ? explicitParent : groupParent;
        if (parent) result.transform.SetParent(parent, false);
        result.transform.position = pivotWS;

        var mrf = result.AddComponent<MeshFilter>();
        var mrr = result.AddComponent<MeshRenderer>();
        mrf.sharedMesh = finalMesh;
        mrr.sharedMaterials = materials.ToArray();
        return result;
    }

    void MoveObjects(List<GameObject> objs)
    {
        if (objs == null || objs.Count == 0) return;

        Vector3 target;
        switch (moveAllTo)
        {
            default:
            case MoveAllTarget.None: return;
            case MoveAllTarget.FirstObject: target = objs[0].transform.position; break;
            case MoveAllTarget.BoundsCenter:
                var b = ComputeWorldBoundsForPreview(objs);
                target = b.center; break;
            case MoveAllTarget.WorldOrigin: target = Vector3.zero; break;
            case MoveAllTarget.WorldCoordinate: target = moveWorldCoordinate; break;
            case MoveAllTarget.SelectedObject: target = Selection.activeTransform ? Selection.activeTransform.position : Vector3.zero; break;
            case MoveAllTarget.Parent:
                target = explicitParent ? explicitParent.position : Vector3.zero; break;
        }

        var center = ComputeWorldBoundsForPreview(objs).center;
        var delta = target - center;
        foreach (var go in objs) if (go) go.transform.position += delta;
    }

    // -------------- Convert to Shrub / Rebuild (reflection safe) --------------
    void TryConvertToShrub(GameObject go, int distance)
    {
        if (!go) return;
        var type = FindTypeByName("ConvertToShrub");
        if (type == null) { Debug.LogWarning("ConvertToShrub not found in project."); return; }
        var comp = Undo.AddComponent(go, type);
        var prop = type.GetProperty("RenderDistance");
        if (prop != null && prop.CanWrite && prop.PropertyType == typeof(int))
            prop.SetValue(comp, distance);
        var method = type.GetMethod("Apply") ?? type.GetMethod("Convert") ?? type.GetMethod("Run");
        if (method != null) method.Invoke(comp, null);
    }

    void TryRebuildInstancedCollision(GameObject go)
    {
        if (!go) return;
        var type = FindTypeByName("InstancedMeshCollider") ?? FindTypeByName("Instanced Mesh Collider") ??
                   FindTypeByName("InstancedMeshCollision");
        if (type != null && typeof(Component).IsAssignableFrom(type))
        {
            foreach (var c in go.GetComponents(type)) if (c) Undo.DestroyObjectImmediate(c as Component);
            var comp = Undo.AddComponent(go, type);
            var m = type.GetMethod("Rebuild") ?? type.GetMethod("Build") ?? type.GetMethod("Setup");
            if (m != null) { try { m.Invoke(comp, null); } catch {} }
        }
        else
        {
            var mf = go.GetComponent<MeshFilter>();
            if (mf && mf.sharedMesh)
            {
                var mc = go.GetComponent<MeshCollider>() ?? Undo.AddComponent<MeshCollider>(go);
                mc.sharedMesh = mf.sharedMesh; mc.convex = false;
            }
        }
    }

    static Type FindTypeByName(string name)
    {
        var guids = AssetDatabase.FindAssets("t:MonoScript");
        foreach (var g in guids)
        {
            var path = AssetDatabase.GUIDToAssetPath(g);
            var ms = AssetDatabase.LoadAssetAtPath<MonoScript>(path);
            if (!ms) continue;
            if (ms.name == name) { var t = ms.GetClass(); if (t != null) return t; }
        }
        return Type.GetType(name);
    }

    // ---------------------- Utilities ----------------------
    static string ApplyIncremental(string baseName, bool inc, Dictionary<string,int> counters, string format = "{0}_{1:000}")
    {
        if (!inc) return baseName;
        if (!counters.TryGetValue(baseName, out var n)) n = 0;
        n++; counters[baseName] = n;
        return string.Format(format, baseName, n);
    }

    void DrawDarkHeader(string text)
    {
        var rect = GUILayoutUtility.GetRect(1, 20, GUILayout.ExpandWidth(true));
        EditorGUI.DrawRect(rect, new Color(0.18f, 0.18f, 0.18f, 1f));
        var lbl = new Rect(rect.x + 6, rect.y, rect.width - 12, rect.height);
        GUI.Label(lbl, text, EditorStyles.boldLabel);
    }

    void DrawInfoBadgeForPrefix(string pfx)
    {
        // evaluate count without forcing layout exceptions
        int count = 0;
        if (!string.IsNullOrEmpty(pfx) && pfx.Length >= 3)
        {
            count = Resources.FindObjectsOfTypeAll<Transform>()
                .Count(t => t && t.gameObject.scene.IsValid() && t.gameObject.name.StartsWith(pfx));
        }

        var c = GUILayoutUtility.GetRect(60, 18, GUILayout.Width(130));
        InfoBadge(c, count == 0 ? "⚠ no assets found" : $"{count} object(s) found",
            count == 0 ? new Color(0.8f,0.55f,0.15f,1) : new Color(0.25f,0.6f,0.25f,1));
    }

    // Small pill badge
    void InfoBadge(Rect r, string text, Color col)
    {
        var bg = new Color(col.r, col.g, col.b, 0.18f);
        var border = new Color(col.r, col.g, col.b, 0.85f);
        var inner = new Rect(r.x, r.y, r.width, r.height);
        EditorGUI.DrawRect(inner, bg);
        // border line
        EditorGUI.DrawRect(new Rect(inner.x, inner.yMax-1, inner.width, 1), border);
        var style = new GUIStyle(EditorStyles.miniLabel) { alignment = TextAnchor.MiddleCenter };
        var old = GUI.color; GUI.color = border;
        GUI.Label(inner, text, style);
        GUI.color = old;
    }

    // Randomize helper (used by your button)
    void RandomizeAllTransformParameters()
    {
        rotationSeed = UnityEngine.Random.Range(1, int.MaxValue);
        scaleSeed    = UnityEngine.Random.Range(1, int.MaxValue);
        locationSeed = UnityEngine.Random.Range(1, int.MaxValue);
        Repaint();
    }

    // Save single result from preview (when only one)
    void SaveFromPreviewSingle()
    {
        if (!CanSaveFromPreview()) return;
        var candidates = Resources.FindObjectsOfTypeAll<Transform>()
            .Where(t => t && t.gameObject.scene.IsValid() && t.gameObject.name.StartsWith(prefix))
            .Select(t => t.gameObject).ToList();
        if (candidates.Count != 1) return;

        var go = candidates[0];
        var mfs = go.GetComponentsInChildren<MeshFilter>(true);
        if (mfs.Length == 0) { EditorUtility.DisplayDialog("Nothing to save", "No MeshFilters on the single object.", "OK"); return; }

        var temp = new GameObject(string.IsNullOrEmpty(forcedName) ? go.name : forcedName);
        Undo.RegisterCreatedObjectUndo(temp, "Create temp for saving");
        foreach (var c in go.GetComponentsInChildren<Transform>(true))
        {
            if (!c || c == go.transform) continue;
        }

        var path = EditorUtility.SaveFilePanelInProject("Save From Preview As", go.name, "prefab", "Path");
        if (!string.IsNullOrEmpty(path))
        {
            var prefab = PrefabUtility.SaveAsPrefabAsset(go, path);
            if (prefab) Debug.Log("Saved: " + path);
        }
        DestroyImmediate(temp);
    }

    // ---------------------- External viewport (Pass I) ----------------------
    public class ExternalViewportWindow : EditorWindow
    {
        PlaceholderSwitcher owner;
        SceneView sceneView;
        Vector2 lastSize;

        public static ExternalViewportWindow Open(PlaceholderSwitcher owner)
        {
            var w = CreateInstance<ExternalViewportWindow>();
            w.titleContent = new GUIContent("Model Viewport");
            w.minSize = new Vector2(320, 240);
            w.owner = owner;
            w.ShowUtility(); // stays in front
            w.Focus();
            return w;
        }

        void OnEnable() { sceneView = SceneView.lastActiveSceneView; lastSize = position.size; }
        void OnFocus()  { sceneView = SceneView.lastActiveSceneView; }
        void OnHierarchyChange() { Repaint(); }
        void OnProjectChange() { Repaint(); }

        public void SyncFromSceneView()
        {
            sceneView = SceneView.lastActiveSceneView;
            Repaint();
        }

        void OnGUI()
        {
            sceneView = SceneView.lastActiveSceneView;

            var r = GUILayoutUtility.GetRect(10, 10, position.height - 10, position.height - 10, GUILayout.ExpandWidth(true), GUILayout.ExpandHeight(true));
            if (sceneView && sceneView.camera)
            {
                var cam = sceneView.camera;
                // Draw the SceneView camera to this window
                EditorGUI.DrawPreviewTexture(r, cam.targetTexture ? cam.targetTexture : Texture2D.blackTexture, null,
                    UnityEngine.ScaleMode.StretchToFill);
            }
            else
            {
                EditorGUI.DrawRect(r, new Color(0.08f,0.08f,0.08f,1));
                GUI.Label(r, "Open a Scene view to mirror here.", new GUIStyle(EditorStyles.centeredGreyMiniLabel){alignment=TextAnchor.MiddleCenter});
            }

            if (owner && owner.autoSyncViewport && Event.current.type == EventType.Repaint)
                owner.Repaint(); // keep main window active when auto-syncing
        }
    }
}
#endif
